<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Sumo Blocks: 2 Players</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #222; font-family: 'Segoe UI', sans-serif; touch-action: none; user-select: none; -webkit-user-select: none; }
        
        /* UI Elements */
        #score-board {
            position: absolute; top: 20px; left: 50%; transform: translateX(-50%);
            display: flex; gap: 40px; font-size: 40px; font-weight: bold; color: white;
            z-index: 10; text-shadow: 0 2px 5px rgba(0,0,0,0.5);
            background: rgba(0,0,0,0.3); padding: 10px 30px; border-radius: 20px;
        }
        .p1-score { color: #ff4444; }
        .p2-score { color: #4444ff; }

        #game-msg {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            font-size: 60px; color: yellow; font-weight: 900; text-shadow: 0 5px 10px black;
            display: none; pointer-events: none; z-index: 20; white-space: nowrap;
        }

        /* Controls Containers */
        .controls-area {
            position: absolute; bottom: 20px; width: 180px; height: 180px;
            display: grid; grid-template-columns: 1fr 1fr 1fr; grid-template-rows: 1fr 1fr 1fr;
            z-index: 15;
        }
        #controls-p1 { left: 20px; }
        #controls-p2 { right: 20px; }

        .dpad-btn {
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.4);
            border-radius: 10px;
            display: flex; justify-content: center; align-items: center;
            font-size: 30px; cursor: pointer;
            transition: background 0.1s;
        }
        .dpad-btn:active, .dpad-btn.pressed { background: rgba(255, 255, 255, 0.6); }

        /* P1 Color Tint */
        #controls-p1 .dpad-btn { border-color: rgba(255, 100, 100, 0.5); }
        /* P2 Color Tint */
        #controls-p2 .dpad-btn { border-color: rgba(100, 100, 255, 0.5); }

        /* Grid positioning for buttons */
        .btn-up { grid-column: 2; grid-row: 1; }
        .btn-left { grid-column: 1; grid-row: 2; }
        .btn-down { grid-column: 2; grid-row: 2; }
        .btn-right { grid-column: 3; grid-row: 2; }

    </style>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
            }
        }
    </script>
</head>
<body>

    <div id="score-board">
        <span class="p1-score" id="score-p1">0</span>
        <span>-</span>
        <span class="p2-score" id="score-p2">0</span>
    </div>

    <div id="game-msg">¡JUGADOR 1 GANA!</div>

    <div id="controls-p1" class="controls-area">
        <div class="dpad-btn btn-up" data-key="p1-up">⬆️</div>
        <div class="dpad-btn btn-left" data-key="p1-left">⬅️</div>
        <div class="dpad-btn btn-down" data-key="p1-down">⬇️</div>
        <div class="dpad-btn btn-right" data-key="p1-right">➡️</div>
    </div>

    <div id="controls-p2" class="controls-area">
        <div class="dpad-btn btn-up" data-key="p2-up">⬆️</div>
        <div class="dpad-btn btn-left" data-key="p2-left">⬅️</div>
        <div class="dpad-btn btn-down" data-key="p2-down">⬇️</div>
        <div class="dpad-btn btn-right" data-key="p2-right">➡️</div>
    </div>

    <script type="module">
        import * as THREE from 'three';

        // --- CONFIGURACIÓN ---
        // La grilla es 100x100. Cada celda es de 10 unidades.
        // Tamaño total = 1000 x 1000 unidades.
        const CONF = { 
            gridDivisions: 100, 
            gridSize: 1000, // 100 celdas * 10 unidades
            cellSize: 10,
            speed: 300, 
            knockbackForce: 1200, // Fuerza del golpe
            friction: 0.92,       // Desaceleración tras golpe
            playerSize: 8         // Tamaño del cubo
        };

        let camera, scene, renderer;
        let p1, p2;
        let clock = new THREE.Clock();
        
        // Estado del juego
        let scores = { p1: 0, p2: 0 };
        let isResetting = false;

        // Inputs (Doble input para multitouch)
        const inputs = {
            p1: { up: false, down: false, left: false, right: false },
            p2: { up: false, down: false, left: false, right: false }
        };

        function init() {
            // Escena
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x111111);

            // Cámara (Vista cenital "Top Down")
            const aspect = window.innerWidth / window.innerHeight;
            // Usamos OrthographicCamera para que la grilla se vea perfecta y plana (mejor jugabilidad 2D)
            const d = 600;
            camera = new THREE.OrthographicCamera(-d * aspect, d * aspect, d, -d, 1, 2000);
            camera.position.set(0, 500, 0); // Arriba
            camera.lookAt(0, 0, 0); // Mirando al centro

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            // Luces
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(100, 200, 50);
            scene.add(dirLight);

            // Grilla
            const gridHelper = new THREE.GridHelper(CONF.gridSize, CONF.gridDivisions, 0x444444, 0x222222);
            scene.add(gridHelper);

            // Piso invisible (para detectar caídas visualmente)
            const planeGeo = new THREE.PlaneGeometry(CONF.gridSize, CONF.gridSize);
            const planeMat = new THREE.MeshBasicMaterial({ color: 0x222222, transparent: true, opacity: 0.5, side: THREE.DoubleSide });
            const plane = new THREE.Mesh(planeGeo, planeMat);
            plane.rotation.x = -Math.PI / 2;
            plane.position.y = -1; // Justo debajo de la grilla
            scene.add(plane);

            // Crear Jugadores
            p1 = createPlayer(0xff0000, -200); // Rojo izquierda
            p2 = createPlayer(0x0088ff, 200);  // Azul derecha

            // Eventos
            setupTouchControls();
            window.addEventListener('resize', onResize);

            animate();
        }

        function createPlayer(color, startX) {
            const geo = new THREE.BoxGeometry(CONF.playerSize * 2, CONF.playerSize * 2, CONF.playerSize * 2);
            const mat = new THREE.MeshStandardMaterial({ color: color, roughness: 0.2 });
            const mesh = new THREE.Mesh(geo, mat);
            
            // Añadir borde negro para que se vea mejor
            const edges = new THREE.LineSegments(new THREE.EdgesGeometry(geo), new THREE.LineBasicMaterial({ color: 0x000000 }));
            mesh.add(edges);

            mesh.position.set(startX, CONF.playerSize, 0);
            
            // Propiedades físicas personalizadas
            mesh.userData = {
                velocity: new THREE.Vector3(),
                isKnocked: false, // Si está volando por choque
                knockTimer: 0,
                startPos: new THREE.Vector3(startX, CONF.playerSize, 0)
            };

            scene.add(mesh);
            return mesh;
        }

        function update(delta) {
            if(isResetting) return;

            // Físicas P1
            updatePlayerPhysics(p1, inputs.p1, delta);
            // Físicas P2
            updatePlayerPhysics(p2, inputs.p2, delta);

            // Colisión entre jugadores
            checkCollision();

            // Chequear condiciones de victoria (caída de la grilla)
            checkWinCondition();
        }

        function updatePlayerPhysics(player, input, delta) {
            const vel = player.userData.velocity;

            // Si fue golpeado, no tiene control, solo inercia
            if (player.userData.isKnocked) {
                // Aplicar fricción fuerte para frenar el vuelo
                vel.multiplyScalar(CONF.friction); 
                
                player.userData.knockTimer -= delta;
                if(player.userData.knockTimer <= 0 && vel.length() < 10) {
                    player.userData.isKnocked = false; // Recupera control
                }
            } else {
                // Movimiento normal por input
                vel.set(0, 0, 0);
                if (input.up) vel.z = -CONF.speed;
                if (input.down) vel.z = CONF.speed;
                if (input.left) vel.x = -CONF.speed;
                if (input.right) vel.x = CONF.speed;
            }

            // Gravedad simple (si sale de la plataforma)
            const limit = CONF.gridSize / 2;
            const isOffPlatform = Math.abs(player.position.x) > limit || Math.abs(player.position.z) > limit;

            if (isOffPlatform) {
                player.position.y -= 300 * delta; // Cae rápido
                player.rotation.x += 5 * delta; // Gira al caer
                player.rotation.z += 5 * delta;
            } else {
                player.position.y = CONF.playerSize; // Mantenerse en el suelo
                player.rotation.set(0,0,0);
            }

            // Aplicar movimiento
            player.position.x += vel.x * delta;
            player.position.z += vel.z * delta;
        }

        function checkCollision() {
            // Distancia entre P1 y P2
            const dist = p1.position.distanceTo(p2.position);
            const minDist = CONF.playerSize * 4; // Tamaño de hitbox (2 cubos)

            // Si chocan y no se están cayendo
            if (dist < minDist && p1.position.y > 0 && p2.position.y > 0) {
                
                // Generar ángulo aleatorio (0 a 360 grados)
                // El prompt dice: "vuelen de forma aleatoria en alguna dirección"
                const randomAngle1 = Math.random() * Math.PI * 2;
                const randomAngle2 = Math.random() * Math.PI * 2;

                // Calcular vectores de fuerza
                // Fuerza para recorrer aprox 5 celdas (5 * 10 = 50 unidades)
                // Con fricción, necesitamos un impulso inicial alto.
                applyKnockback(p1, randomAngle1);
                applyKnockback(p2, randomAngle2);
            }
        }

        function applyKnockback(player, angle) {
            player.userData.isKnocked = true;
            player.userData.knockTimer = 1.0; // 1 segundo de "aturdimiento"
            
            // Seteamos velocidad en la dirección aleatoria
            player.userData.velocity.x = Math.cos(angle) * CONF.knockbackForce;
            player.userData.velocity.z = Math.sin(angle) * CONF.knockbackForce;
        }

        function checkWinCondition() {
            if (p1.position.y < -100) handleWin('p2');
            else if (p2.position.y < -100) handleWin('p1');
        }

        function handleWin(winner) {
            isResetting = true;
            const msgEl = document.getElementById('game-msg');
            const p1ScoreEl = document.getElementById('score-p1');
            const p2ScoreEl = document.getElementById('score-p2');

            if (winner === 'p1') {
                scores.p1++;
                msgEl.innerText = "¡ROJO GANA!";
                msgEl.style.color = "#ff4444";
            } else {
                scores.p2++;
                msgEl.innerText = "¡AZUL GANA!";
                msgEl.style.color = "#4444ff";
            }

            p1ScoreEl.innerText = scores.p1;
            p2ScoreEl.innerText = scores.p2;
            msgEl.style.display = 'block';

            setTimeout(() => {
                resetRound();
            }, 2000);
        }

        function resetRound() {
            p1.position.copy(p1.userData.startPos);
            p2.position.copy(p2.userData.startPos);
            
            p1.rotation.set(0,0,0);
            p2.rotation.set(0,0,0);

            p1.userData.velocity.set(0,0,0);
            p2.userData.velocity.set(0,0,0);
            p1.userData.isKnocked = false;
            p2.userData.isKnocked = false;

            document.getElementById('game-msg').style.display = 'none';
            isResetting = false;
        }

        // --- CONTROLES TÁCTILES ---
        function setupTouchControls() {
            const btns = document.querySelectorAll('.dpad-btn');
            
            // Función para manejar el estado del botón
            const handleBtn = (el, isPressed) => {
                const key = el.dataset.key; // ej: p1-up
                const [player, dir] = key.split('-'); // ['p1', 'up']
                
                if (isPressed) {
                    inputs[player][dir] = true;
                    el.classList.add('pressed');
                } else {
                    inputs[player][dir] = false;
                    el.classList.remove('pressed');
                }
            };

            btns.forEach(btn => {
                // Touch
                btn.addEventListener('touchstart', (e) => { e.preventDefault(); handleBtn(btn, true); }, {passive: false});
                btn.addEventListener('touchend', (e) => { e.preventDefault(); handleBtn(btn, false); });
                
                // Mouse (para pruebas en PC)
                btn.addEventListener('mousedown', (e) => { handleBtn(btn, true); });
                btn.addEventListener('mouseup', (e) => { handleBtn(btn, false); });
                btn.addEventListener('mouseleave', (e) => { handleBtn(btn, false); });
            });
        }

        function onResize() {
            const aspect = window.innerWidth / window.innerHeight;
            const d = 600;
            camera.left = -d * aspect;
            camera.right = d * aspect;
            camera.top = d;
            camera.bottom = -d;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();
            update(delta);
            renderer.render(scene, camera);
        }

        init();
    </script>
</body>
</html>
